(
 (plt:framework-pref:framework:exit-when-no-frames #t)
 (plt:framework-pref:framework:standard-style-list:font-size #2(#hash((((1669 939) (1669 939)) . 12)) 12))
 (plt:framework-pref:framework:color-scheme classic)
 (|plt:DrRacket 8.3-splash-max-width| 1010)
 (plt:framework-pref:plt:debug-tool:stack/variable-area 9/10)
 (plt:framework-pref:drracket:unit-window-size-percentage 1/2)
 (plt:framework-pref:drracket:window-size #hash((((-1670 0 1669 939) (0 0 1669 939)) . (#f 800 869)) (#f . (#f 800 869))))
 (plt:framework-pref:drracket:window-position #hash((((-1670 0 1669 939) (0 0 1669 939)) . (0 -827 26)) (#f . (0 -827 26))))
 (plt:framework-pref:framework:verify-exit #t)
 (plt:framework-pref:drracket:console-previous-exprs ())
 (readline-input-history
  (
   #"(callcc2)"
   #"(define callcc2\n    (lambda ()\n      (define k 0)\n      (+ 2 (let/cc cc (set! k cc) 3))))"
   #"(define callcc2\n    (lambda ()\n      (define k 0)\n      (+ 2 (let/cc cc (set! k cc) 3))); let/cc is a short hand for call/cc))\n  (callcc2)\n  ; let/cc is a short hand for call/cc))"
   #"(callcc2("
   #"(define callcc2\n    (lambda ()\n      (define k 0)\n      (+ 2 (let/cc cc (set! k cc) 3))); let/cc is a short hand for call/cc))"
   #"(notwo)"
   #"; (define (try-or t1 t2)\n  ;   (lambda (success failure)\n  ;     ()\n  ;     )\n  ;   )"
   #";; logic programming\n  ;; 1. search\n  ;; 2. binding\n  ;; e.g sudoku, some knots we can tweak, some knot config will satisfy our\n  ;;     constraint.\n  ;; P : we can solve the problems efficiently\n  ;; NP: We can recognizing solutions (If we have orcale give us solution)\n  ;; Sudoku is NP problem, we can verify in O(2n) but we can't find a solution\n  ;; very efficiently.\n  ;; Cast problems into a satisfiability problem.\n  ;; e.g tic tac toe\n  ;; turn the board into a satisfiability problem:\n  ;;   0 1 2\n  ;;   3 4 5\n  ;;   6 7 8\n  ;;   (0 && 1 && 2) || (3 && 4 && 5) || (6 && 7 && 8) ||\n  ;;   (0 && 3 && 6) || ... || (no enough space)\n  ;; What do we want for this search engine?\n  ;;  - on each search step we want to know if the constriant is satisfied.\n  ;;  - base on whether it's satisfied, we want to choose different things to do.\n  ;; How?\n  ;;  - every computation is parameterized with two continuation:\n  ;;    success and failure. Which one is called base on the result of the\n  ;;    computation\n  ;;  - wrap logic connectives with continuations above.\n  (define (try-and t1 t2)\n    (lambda (success failure)\n      (begin (let/cc succ\n               (t1 succ failure))\n             (t2 success failure))))"
   #"(define notwo\n    (lambda ()\n      (try\n       (begin (display \"1\\n\") (raise 'some-error) (display \"2\\n\"))\n       (catch (display \"[error]: \")))))"
   #";; use call/cc to implement exception\n  ; (define-syntax try\n  ;   (syntax-rules (catch)\n  ;     ((_ body (catch handler))\n  ;      (call/cc (lambda (exit)\n  ;                 (call-with-exception-handler\n  ;                  (lambda (condition)\n  ;                    handler\n  ;                    (exit condition))\n  ;                  (lambda () body)))))))\n  ; (try (begin (display \"hi\\n\")\n  ;             (raise 'some-error)\n  ;             (display \"two\\n\")\n  ;             )\n  ;      (catch (display \"error\\n\")))\n  ; (define-syntax try\n  ;   (syntax-rules (catch)\n  ;     ((_ body (catch handler))\n  ;      (call/cc (lambda (exit)\n  ;                 (call-with-exception-handler    ; takes succ and fail\n  ;                  (lambda (condition)\n  ;                    handler\n  ;                    (exit condition))\n  ;                  (lambda () body)))))))\n  (define-syntax try\n    (syntax-rules (catch)\n      ((_ body (catch handler))\n       (call/cc (lambda (exit)\n                  (call-with-exception-handler\n                   (lambda (condition) handler (exit condition))\n                   (lambda () body)))))))"
   #"(define callcc-desugared\n    (lambda ()\n      (define cc (lambda (hole) (+ 2 hole)))\n      (cc 3)))"
   #";; call/cc occupies a hole in a computation, and then make the entire\n  ;; surrounding code into a lambda, the lambda is the current continuation to\n  ;; whatever written inside callcc.\n  ;; call/cc takes another lambda, which takes a parameter cc\n  ;; (current continuation). This way you can control where to call the current\n  ;; continuation.\n  (define callcc1\n    (lambda ()\n      (define k 0)\n      (+ 2 (call/cc (lambda (cc) (set! k cc) 3)))))"
   #"#lang lazy"
   #"(notwo )"
   #"(define notwo\n    (lambda ()\n      (try (begin (display \"1\\n\") (raise 'some-error) (display \"2\\n\"))\n           (catch (display \"[error]: \")))))"
   #"(define-syntax try\n    (syntax-rules (catch)\n      ((_ body (catch handler))\n       (call/cc (lambda (exit)\n                  (call-with-exception-handler\n                   (lambda (condition) handler (exit condition))\n                   (lambda () body)))))))"
   #"(callcc1)"
   #"(callcc-desugared )"
   #";; call/cc occupies a hole in a computation, and then make the entire\n  ;; surrounding code into a lambda, the lambda is the current continuation to\n  ;; whatever written inside callcc.\n  ;; call/cc takes another lambda, which takes a parameter cc\n  ;; (current continuation). This way you can control where to call the current\n  ;; continuation.\n  (define (callcc1)\n    (define k 0)\n    (+ 2 (call/cc (lambda (cc) (set! k cc) 3))))"
   #"notwo"
   #"(define-syntax try\n    (syntax-rules (catch)\n      ((_ body (catch handler))\n       (call/cc (lambda (exit)\n                  (call-with-exception-handler    ; takes succ and fail\n                   (lambda (condition)\n                     handler\n                     (exit condition))\n                   (lambda () body)))))))"
   #"(define notwo\n    (lambda ()\n      (try (begin (display \"1\\n\") (raise 'some-error) (display \"2\\n\"))\n           (catch (display \"error.\")))))"
   #";; use call/cc to implement exception\n  ; (define-syntax try\n  ;   (syntax-rules (catch)\n  ;     ((_ body (catch handler))\n  ;      (call/cc (lambda (exit)\n  ;                 (call-with-exception-handler\n  ;                  (lambda (condition)\n  ;                    handler\n  ;                    (exit condition))\n  ;                  (lambda () body)))))))\n  ; (try (begin (display \"hi\\n\")\n  ;             (raise 'some-error)\n  ;             (display \"two\\n\")\n  ;             )\n  ;      (catch (display \"error\\n\")))\n  (define-syntax try\n    (syntax-rules (catch)\n      ((_ body (catch handler))\n       (call/cc (lambda (exit)\n                  (call-with-exception-handler    ; takes succ and fail\n                   (lambda (condition)\n                     handler\n                     (exit condition))\n                   (lambda () body)))))))"
   #"(define (callcc-desugared _)\n    (define cc (lambda (hole) (+ 2 hole)))\n    (cc 3))"
   #";; call/cc occupies a hole in a computation, and then make the entire\n  ;; surrounding code into a lambda, the lambda is the current continuation to\n  ;; whatever written inside callcc.\n  ;; call/cc takes another lambda, which takes a parameter cc\n  ;; (current continuation). This way you can control where to call the current\n  ;; continuation.\n  (define (callcc1 _)\n    (define k 0)\n    (+ 2 (call/cc (lambda (cc) (set! k cc) 3))))"
   #"(try (begin (display \"hi\\n\")\n              (raise 'some-error)\n              (display \"two\\n\")\n              )\n       (catch (display \"error\\n\")))"
   #";; use call/cc to implement exception\n  (define-syntax try\n    (syntax-rules (catch)\n      ((_ body (catch handler))\n       (call/cc (lambda (exit)\n                  (call-with-exception-handler\n                   (lambda (condition)\n                     handler\n                     (exit condition))\n                   (lambda () body)))))))"
   #"(callcc-desugared \"\")"
   #"(callcc-desugared 3)"
   #"(callcc1 0)"
   #"(define (callcc1 _)\n    (define k 0)\n    (+ 2 (call/cc (lambda (cc) (set! k cc) 3))))"
   #"(x 10)"
   #"(+ 2 (call/cc (lambda (cc) (set! x cc) 3)))"
   #"(define x 0)"
   #"; (define (callcc-desugared _)\n  ;   (let ((x 0))\n  ;     ((lambda (cc)\n  ;        )\n  ;      (lambda (n) (+ 2 n))))\n  ;    )\n  ;; logic programming\n  ;; 1. search\n  ;; 2. binding\n  ;; e.g sudoku, some knots we can tweak, some knot config will satisfy our\n  ;;     constraint.\n  ;; P : we can solve the problems efficiently\n  ;; NP: We can recognizing solutions (If we have orcale give us solution)\n  ;; Sudoku is NP problem, we can verify in O(2n) but we can't find a solution\n  ;; very efficiently.\n  ;; Cast problems into a satisfiability problem.\n  ;; e.g tic tac toe\n  ;; turn the board into a satisfiability problem:\n  ;;   0 1 2\n  ;;   3 4 5\n  ;;   6 7 8\n  ;;   (0 && 1 && 2) || (3 && 4 && 5) || (6 && 7 && 8) ||\n  ;;   (0 && 3 && 6) || ... || (no enough space)\n  ;; What do we want for this search engine?\n  ;;  - on each search step we want to know if the constriant is satisfied.\n  ;;  - base on whether it's satisfied, we want to choose different things to do.\n  ;; How?\n  ;;  - every computation is parameterized with two continuation:\n  ;;    success and failure. Which one is called base on the result of the\n  ;;    computation\n  ;;  - wrap logic connectives with continuations above.\n  (define (try-and t1 t2)\n    (lambda (success failure)\n      (begin (let/cc succ\n               (t1 succ failure))\n             (t2 success failure))))"
   #";; following call/cc is the same as\n  (define x 0)"
   #"(callcc1 0("
   #"(callcc 0("
   #"(define (callcc1 _)\n    (define x 0)\n    (begin\n      (+ 2 (call/cc (lambda (cc) (set! x cc) 3)))\n      (x 10)\n      )\n    )"
   #"(define (callcc1 _)\n    (define x 0)\n    (+ 2 (call/cc (lambda (cc) (set! x cc) 3)))\n    (x 10))"
   #";; following call/cc is the same as\n  (define callcc1\n    (let ((x 0))\n      (begin\n        (+ 2 (call/cc (lambda (cc) (set! x cc) 3)))\n        (x 10))))"
   #"(define (callcc1 _)\n    (let ((x 0))\n      (begin\n        (+ 2 (call/cc (lambda (cc) (set! x cc) 3)))\n        (x 10))))"
   #"(define (callcc1 _)\n    (let ((x 0))\n      (+ 2 (call/cc (lambda (cc) (set! x cc) 3)))\n      (x 10)\n      ))"
   #"(define (callcc1 _)\n    (let ((x 0))\n      (+ 2 (call/cc (lambda (cc) (set! x cc) 3)))))"
   #"(x 20)"
   #";; following call/cc is the same as\n  (define (callcc1 _)\n    (let ((x 0))\n      (+ 2 (call/cc         ; entire surrounding becomes a continuation\n            (lambda (cc)\n              (set! x cc)\n              3)))\n      (x 5)))"
   #";; following call/cc is the same as\n  (define (callcc1 _)\n    (let ((x 0))\n      (+ 2 (call/cc         ; entire surrounding becomes a continuation\n            (lambda (cc)\n              (set! x cc)\n              3)))))"
   #"(let ((x 0))\n    (+ 2 (call/cc\n          (lambda (cc)\n            (set! x cc)\n            3))))"
   #"(module lazy (enter! \"c1.rkt\"))"
   #"(modeu"
   #"(fact: 10)"
   #"(bottom '())"
   #"(bottom ())"
   #"(define fact:\n    (Y (lambda (fct)\n         (lambda (N)\n           (cnd (Z? N)\n                (suc Z)\n                (mult N (fct (pred N))))))))"
   #"(define Y (lambda (g) (lambda (f) (f f)) (lambda (f) (g (f f)))))"
   #";; (0, 0), (0, 1), (1, 2) ... once hit (1, 2), 1 is the pred.\n  (define (pred N)\n    (((N (lambda (p)\n           (pair (p snd)\n                 (suc (p snd)))))\n      (pair Z Z))\n     fst))"
   #";; Z is identity, falsity will not be called.\n  (define (Z? N) ((N (lambda (_) falsity)) truth))"
   #"(define (mult M N) (M (N add) N))"
   #"(define (add M N) ((M suc) N))"
   #"(define (i->n i) (if (zero? i) Z (suc (i->n (sub1 i)))))"
   #"(define (n->i N) ((N add1) 0))"
   #"(define (suc N)\n    (lambda (f)\n      (lambda (x)\n        (f ((N f) x)))))    ;; first apply f N times, then apply one more time."
   #"(define Z (lambda (f) id))"
   #";; number. take f and applies it n times.\n  (define id (lambda (x) x))"
   #"(define (falsity a b) b)"
   #"(define (truth a b) a)"
   #";; conditional. needs lazy\n  (define (cnd c t e) (c t e))"
   #"(define (snd a b) b)"
   #"(define (fst a b) a)"
   #";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ;; pair\n  (define (pair a b) (lambda (sel) (sel a b)))"
   #";; refactor fact1 above.\n  (define Y1\n    (let ((fork\n            (lambda (g)\n              (lambda (f)\n                (g (f f))))\n            ))\n      fork fork))"
   #"(define bottom (lambda (_) (Omega Omega)))"
   #";; simplest self reflication\n  (define Omega (lambda (x) (x x)))"
   #";; abstract recursion\n  (define fact1\n    (let ((mkfact\n           (lambda (f)\n             (lambda (n)\n               (if (zero? n)\n                   1\n                   (* n ((f f) (sub1 n))))))))\n      (mkfact mkfact)))"
   #";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n  ; how many things we can get rid of from a langauge. with only lambda\n  ; encoding things in lambda\n  ;; goal: implement fact in lambda only\n  (define (fact n)\n    (if (zero? n) 1\n        (* n (fact (sub1 n)))))"
  ))
)
